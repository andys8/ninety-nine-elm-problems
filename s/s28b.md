# Problem 28.b

##Sort list of lists by the frequency of the list length.

### Solution 1

This solution builds a list of pairs where each pair has a list length and the frequency of that list length. ```lenFreq``` calculates the frequency of a length. 
```sortLenFreq``` finds a index of a specified length in the list of pair which can by passed to ```List.sortBy```.  Note the partial application of the pairs list to the comparison function. 

```elm
sortByLengthFrequency : List (List a) -> List (List a)
sortByLengthFrequency xs =
    let
        lenFreqs =
            lenFreq xs
    in
        List.sortBy (sortLenFreq lenFreqs) xs


sortLenFreq : List ( Int, Int ) -> List a -> Int
sortLenFreq lenFreqs xs =
    let
        len =
            List.length xs

        tl =
            dropWhile (\( l, f ) -> l /= len) lenFreqs
    in
        snd <| Maybe.withDefault ( 0, 0 ) <| List.head tl


lenFreq : List (List a) -> List ( Int, Int )
lenFreq xs =
    case xs of
        [] ->
            [ ( 0, 0 ) ]

        l :: ls ->
            let
                len =
                    List.length l

                ( l1, l2 ) =
                    List.partition (\x -> List.length x == len) xs

                freq =
                    List.length l1
            in
                if List.isEmpty l2 then
                    [ ( len, freq ) ]
                else
                    ( len, freq ) :: lenFreq l2


dropWhile : (a -> Bool) -> List a -> List a
dropWhile predicate list =
    case list of
        [] ->
            []

        x :: xs ->
            if (predicate x) then
                dropWhile predicate xs
            else
                list
              
```

###Solution 2
This solution is similar to the first, but replaces the list of length/frequency pairs with a Dict. Lengths are the dictionary keys, and frequencies are the value.

```elm

sortByLengthFrequency : List (List a) -> List (List a)
sortByLengthFrequency xs =
    let
        freqs =
            lenFreq xs Dict.empty
    in
        List.sortBy (sortLenFreq freqs) xs


sortLenFreq : Dict.Dict Int Int -> List a -> Int
sortLenFreq lenFreqs xs =
    case Dict.get (List.length xs) lenFreqs of
        -- should never get Nothing
        Nothing ->
            -1

        Just freq ->
            freq


lenFreq : List (List a) -> Dict.Dict Int Int -> Dict.Dict Int Int
lenFreq xs d =
    case xs of
        [] ->
            Dict.empty

        l :: ls ->
            let
                len =
                    List.length l

                ( sameLength, otherLengths ) =
                    List.partition (\x -> List.length x == len) xs

                freq =
                    List.length sameLength
            in
                if List.isEmpty otherLengths then
                    Dict.insert len freq d
                else
                    lenFreq otherLengths (Dict.insert len freq d)
```

[Back to problem](../p/p28b.md)