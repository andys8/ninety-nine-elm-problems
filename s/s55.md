#Problem 55

###Solution 1
Use List.foldl, adds one node at a time.

```elm
balancedTree : Int -> Tree Char
balancedTree n =
     List.foldl (addBalancedNode) Empty <| List.repeat n 'x'

    
addBalancedNode : a -> Tree a -> Tree a
addBalancedNode v tree =
    case tree of
        Empty ->
            Node v Empty Empty
            
        Node v' left right ->
            if count left > count right then
                Node v' left (addBalancedNode v right) 
            else 
                Node v' (addBalancedNode v left) right 
                

-- count number of Nodes in a Tree    
count : Tree a -> Int
count tree = 
    case tree of 
        Empty -> 0
        
        Node n left right ->
            1 + (count left) + (count right)
```

###Solution 2
A more efficient solution could add many nodes at once. In Haskell...

```haskell
cbalTree 0 = [Empty]
cbalTree 1 = [leaf 'x']
cbalTree n = if n `mod` 2 == 1 then 
             [ Branch 'x' l r | l <- cbalTree ((n - 1) `div` 2), 
                                r <- cbalTree ((n - 1) `div` 2) ] 
             else 
             concat [ [Branch 'x' l r, Branch 'x' r l] | l <- cbalTree ((n - 1) `div` 2), 
                                                         r <- cbalTree (n `div` 2) ]
```

[Back to problem](../p/p55.md)