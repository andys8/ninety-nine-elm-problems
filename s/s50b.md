#Problem 50b - Huffman Encoding 
Huffman coding uses variable bit length codes to efficiently encode data. In [Problem 50a](p50a.md) we find the frequencies of each value of our input data. Now use that to build the Huffman codes. See the steps to build a Huffman code from the frequency data [here](http://www.geeksforgeeks.org/greedy-algorithms-set-3-huffman-coding/).

You'll need a binary tree to build the codes. You should complete [Problems 54 through 60](../binary-trees.md) before attempting this problem.


##Example
```elm 
huffman [('a',45),('b',13),('c',12),('d',16),('e',9),('f',5)] == 
[('a',"0"),('b',"101"),('c',"100"),('d',"111"),('e',"1101"),('f',"1100")]
```

##Unit Test
```elm
import Html
import List
import String


type Tree a
    = Empty
    | Node a (Tree a) (Tree a)


type alias Freq = (Char, Int)


huffman : List Freq -> List (Char, String)
huffman list =
    huffCodes "" 
        <| huffTree 
        <| List.map (\x -> Node x Empty Empty) list
        

huffCodes : String -> Tree Freq -> List (Char, String)
huffCodes path tree =
    case tree of
        Empty ->
            [('?', "!")]  -- should never get here  
        
        Node (c, f) Empty Empty ->
            [(c, path)]
            
        Node (c, f) left right ->
            (huffCodes (path ++ "0") left) ++ (huffCodes (path ++ "1") right)
           
    

-- build the binary sort tree order by cummulative frequencies
huffTree : List (Tree Freq) -> Tree Freq
huffTree list =
    case List.sortBy treeFreq list of
        [] ->
            Empty
            
        x :: xs ->
            case xs of
                [] ->
                    x
            
                y :: ys ->
                    huffTree ((merge x y) :: ys)
                    
treeFreq : Tree Freq -> Int
treeFreq t = 
    case t of 
        Empty -> 0 
        Node (v, c) l r-> c
        

merge : Tree Freq -> Tree Freq -> Tree Freq
merge t1 t2 = 
    case t1 of
        Empty ->
            Empty -- we should never have empties here 
                    
        Node (xv, xc) xl xr ->
            case t2 of 
                Empty ->
                    Empty
                Node (yv, yc) yl yr ->
                    Node (xv, xc + yc) t1 t2 
               
    
(?) : a -> Maybe a -> a
(?) d x =
    Maybe.withDefault d x
    
main = Html.text <| toString <| huffman [('a',45),('b',13),('c',12),('d',16),('e',9),('f',5)]
main' =
    Html.text
        (if (test) then
            "Your implementation passed all tests."
         else
            "Your implementation failed at least one test."
        )


test : Bool
test =
    List.all ((==) True)
        [ True
        --huffman [('a',45),('b',13),('c',12),('d',16),('e',9),('f',5)] ==
        --    [('a',"0"),('b',"101"),('c',"100"),('d',"111"),('e',"1101"),('f',"1100")]
        ]
```

#Hints
1. You'll need to create a binary tree, 

## Solutions
[Solutions](../s/s50a.md) 