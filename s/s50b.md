#Problem 50b - Huffman Encoding 
Huffman coding uses variable bit length codes to efficiently encode data. In [Problem 50a](p50a.md) we find the frequencies of each value of our input data. Now use that to build the Huffman codes. See the steps to build a Huffman code from the frequency data [here](http://www.geeksforgeeks.org/greedy-algorithms-set-3-huffman-coding/).


##Example
```elm 
huffman [('a',45),('b',13),('c',12),('d',16),('e',9),('f',5)] == 
[('a',"0"),('b',"101"),('c',"100"),('d',"111"),('e',"1101"),('f',"1100")]
```

##Unit Test
```elm
import Html
import List
import String


huffman : List ( Int, comparable ) -> List (comparable, List Char)
huffman list =
    -- your implementation here
    []

main =
    Html.text
        (if (test) then
            "Your implementation passed all tests."
         else
            "Your implementation failed at least one test."
        )


test : Bool
test =
    List.all ((==) True)
        [ huffman (toChars "hello world") == [('l', "0")]
        , huffman (toChars "hello world") == [('l', "0")]
        , huffman (toChars "hello world") == [('l', "0")]
        ]


toChars : String -> List Char
toChars s =
    case String.uncons s of
        Nothing ->
            []

        Just ( c, cs ) ->
            c :: toChars cs

            
```

#Hints
1. Look at [Problem 9](p/p09.md) and [Problem 10](p/p10.md). Can you use or modify those solutions to this problem? Note we are assuming the type of the input list will be a ```comparable```.

## Solutions
[Solutions](../s/s50a.md) 