# Problem 81

Write a function that, given two nodes a graph, returns all the acyclic paths between the two nodes.

##Example

```elm
paths : (Graph a) a a -> List (List a)

g81 = (['b','c','d','f','g','h','k'], [('b','c'),('b','f'),('c','f'),('f','k'),('g','h')])

paths g81 'k' 'b' == [['k', 'f', 'c', 'b'], ['k', 'f', 'b']]
```

##Unit Test

```elm
import Html
import List
import Set

-- Nodes of a graph must be of type comparable because we define 
type alias Edge comparable = (comparable, comparable)
type alias AdjList comparable = (List((comparable, List comparable)))
type alias Graph comparable = (List comparable, List (Edge comparable))

-- add a path to Graph. Edges should be in either the path or the graph but never both 
type alias GraphPath comparable = (Graph comparable, List comparable)


-- Given two nodes a graph, return all acyclic paths in the graph between the two nodes
findPaths : comparable -> comparable -> Graph comparable -> List (List comparable)
findPaths start goal graph = 
    List.map snd <| findPaths' goal [(graph, [start])]
    
                
-- Given a goal node and a list of path, recursively search each path
-- so we can find all complete paths to the goal
findPaths' : comparable -> List (GraphPath comparable) -> List (GraphPath comparable)
findPaths' goal paths = 
    case paths of
        [] -> []
        
        p :: ps ->
            if endsAt goal p then
                p :: findPaths' goal ps
            else
                findPaths' goal ((extendPath p) ++ ps)


-- given a path, return a list of all edges connecting to the end of the path
extendPath : GraphPath comparable -> List (GraphPath comparable)
extendPath ((gNodes, edges), pathNodes) = 
    case last pathNodes of
        Nothing -> 
            []
        
        Just x ->
            let
                es = List.filter (\(a,b) -> (a == x) || (b == x)) edges
                gs = List.repeat (List.length es) ((gNodes, edges), pathNodes)
            in
                List.filter isAcyclic
                    <|List.map2 (\gp e -> addToPath gp e x) gs es
        

isAcyclic : GraphPath comparable -> Bool
isAcyclic (g, ns) =
    List.length ns == Set.size (Set.fromList ns)


--given a path, and an edge, construct a GraphPath that adds the edge to the path, and updates the graph to remove the edge
addToPath : GraphPath comparable -> Edge comparable -> comparable -> GraphPath comparable
addToPath ((ns, es), ps) (x,y) end =
    let
        es' = Set.toList <| Set.remove (x,y) <| Set.fromList es
        end' = if x == end then y else x
    in
        ((ns, es'), ps ++ [end']) 
    


-- given a value and a path, return if the value matches the last node of the path
endsAt : comparable -> GraphPath comparable -> Bool
endsAt end (g, ns) = 
    case last ns of
        Nothing ->
            False
            
        Just x ->
            x == end
    
    
last : List a -> Maybe a
last list = 
    List.head (List.reverse list)
    
    
main' = Html.text <| toString <| List.sort (findPaths 'f' 'h' graph80b)
main =
    Html.text
        <| case test of 
            0 -> 
                "Your implementation passed all tests."
            1 -> 
                "Your implementation failed one test."
            x -> 
                "Your implementation failed " ++ (toString x) ++ " tests."


test : Int
test =
    List.length <| List.filter ((==) False)
      [ List.sort (findPaths 'c' 'b' graph80) == [['c','b'],['c','f','b']]
      , List.sort (findPaths 'k' 'c' graph80) == [['k','f', 'b', 'c'],['k','f', 'c']]
      , List.sort (findPaths 'x' 'y' graph80) == []
      , List.sort (findPaths 'c' 'y' graph80) == []
      , List.sort (findPaths 'y' 'c' graph80) == []
      , List.sort (findPaths 'f' 'h' graph80b) == [ ['f', 'b', 'g', 'h']
                                                  , ['f', 'c', 'b', 'g', 'h']
                                                  , ['f', 'g', 'h']
                                                  ]
      ]


graph80 = ( [ 'b', 'c', 'd', 'f', 'g', 'h', 'k' ],
            [ ('b','c'), ('b','f'), ('c','f'), ('f','k'), ('g','h') ] )

graph80b = ( [ 'b', 'c', 'd', 'f', 'g', 'h', 'k' ],
            [ ('b','c'), ('b','f'), ('b', 'g'), ('c','f'), ('f', 'g'), ('f','k'), ('g','h') ] )


```

## Solution

[Solution](../s/s81.md)
