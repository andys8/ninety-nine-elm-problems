# Problem 23

Extract a given number of randomly selected elements from a list.

##Referential Transparency
Two plus two equals four. The state of the universe will not influence arithmetic such that next Tuesday two plus two will equal five. 

In pure functional programming languages like Elm functions always produce the same results given the same inputs. This property is called referential transparency. The expression ```List.sum [2, 2]``` is functionally equivalent to the expression ```4```.

Imperative languages have some functions that are not referentially transparent. Here are a couple really  useful ones from C. 
```C
   time_t t = time(NULL); 
   int r = rand();
```

Randomness, by definition, is not referentially transparent. Elm implements psuedo-randomness with the  psuedo-random number generators, which always returns the same result given the same input seed value. It also returns a new seed which can be used in the next call of ```Random.step``` to retrieve the next value in the psuedo-random sequence.

##Example
```elm
randomSelect seed 3 ["Al", "Biff", "Cal", "Dee", "Ed", "Flip"] == ["Cal", "Dee", "Al"]
```
You must use [Elm's Random](http://package.elm-lang.org/packages/elm-lang/core/4.0.5/Random) to implement ```randomSelect```. Use [Random.step](http://package.elm-lang.org/packages/elm-lang/core/4.0.5/Random#step) to generate a pseudo-random number. ```Random.step``` takes a [Generator](http://package.elm-lang.org/packages/elm-lang/core/4.0.5/Random#Generator) and a [Seed](http://package.elm-lang.org/packages/elm-lang/core/4.0.5/Random#Seed). The seed is passed as a parameter to ```randomSelect```. You will need to create a generator such as [Random.int](http://package.elm-lang.org/packages/elm-lang/core/4.0.5/Random#int). 

```Random.step``` will return both a randomly generated value from the generator, and a new seed. You must use the new seed for subsequent random numbers. 

## Unit Test
This unit test uses the Elm Architecture to allow a pseudo-random seed to enter into the pure functional world of Elm. You don't need to understand that this does to solve this problem. 

```elm
import Html exposing (..)
import Html.App as App
import Html.Events exposing (..)
import Random


randomSelect : Random.Seed -> Int -> List a -> (List a, Random.Seed)
randomSelect seed n list =
    -- your implemenation goes here
    ([], seed)
        
        
elementAt : List a -> Int -> Maybe a
elementAt list n =
    case List.drop (n - 1) list of
        [] ->
            Nothing

        y :: ys ->
            Just y
            
dropAt : List a -> Int -> List a
dropAt list n =
 case list of
 [] -> []
 x :: xs ->
 (List.take (n - 1) list) ++ (List.drop n list)

main =
  App.program
    { init = init
    , view = view
    , update = update
    , subscriptions = subscriptions
    }



-- MODEL


type alias Model =
  { intSeed : Int
  }


init : (Model, Cmd Msg)
init =
  (Model 1, Cmd.none)



-- UPDATE


type Msg
  = Test
  | NewFace Int


update : Msg -> Model -> (Model, Cmd Msg)
update msg model =
  case msg of
    Test ->
      (model, Random.generate NewFace (Random.int Random.minInt Random.maxInt))

    NewFace newSeed ->
      (Model newSeed, Cmd.none)



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions model =
  Sub.none



-- VIEW


view : Model -> Html Msg
view model =
  div []
    [ h2 [] [ text (test(model.intSeed)) ]
    , p  [] [ text ("Your lucky number is " ++ (toString (model.intSeed))) ]
    , p  [] [ text ("Your die roll is " ++ (toString (fst (randomSelect (Random.initialSeed model.intSeed) 1 [1..6])))) ]
    , button [ onClick Test ] [ text "Test" ]
    ]


test : Int -> String
test intSeed =
    let
        seed = Random.initialSeed intSeed
        (l1, s1) = randomSelect seed 3 [1..1000]
        (l2, s2) = randomSelect seed 3 [1..1000]
        (l3, s3) = randomSelect s2 3 [1..1000]
        (l4, s4) = randomSelect s3 3 [1..1000]
        (l5, s5) = randomSelect s4 3 ["a", "b"]
        (l6, s6) = randomSelect s5 0 ['a', 'b']
        (l7, s7) = randomSelect s6 -1 ['a', 'b']
        (l8, s8) = randomSelect s7 1 ['a', 'b']
    in
        if 
            List.all ((==) True) 
              [ List.sort l1 == List.sort l2
              , l1 == l2
              , l2 /= l3 -- a billion to one that this won't match
              , List.sort l5 == ["a", "b"]
              , l6 == []
              , l7 == []
              ]
        then
            "Your implementation passed all tests."
        else
            "Your implementation failed at least one test."
        
        

```

##Solutions 
[Solutions](../s/s23.md)