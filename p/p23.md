# Problem 23

Extract a given number of randomly selected elements from a list.

##Example
```elm
randomSelect seed 3 ["Al", "Biff", "Cal", "Dee", "Ed", "Flip"] == ["Cal", "Dee", "Al"]
```

##Randomness in a pure functional language
Two plus two equals four. The state of the universe will not influence arithmetic such that next Tuesday two plus two will equal five. 

In pure functional programming languages like Elm functions always produce the same results given the same inputs. This property is called referential transparency. The expression ```List.sum [2, 2]``` is functionally equivalent to the expression ```4```.

Imperative languages have some functions that are not referentially transparent. Here are a couple really  useful ones from C. 
``` 
   time_t t = time(NULL); 
   int r = rand();
```

Randomness, by definition, is not referentially transparent. Elm implements psuedo-randomness with the  psuedo-random number generators, which always returns the same result given the same input seed value. It also returns a new seed which can be used in the next call of ```Random.step``` to retrieve the next value in the psuedo-random sequence.


## Unit Test
```elm
import Html exposing (..)
import Html.App as App
import Html.Events exposing (..)
import Random


randomSelect : Random.Seed -> Int -> List a -> List a
randomSelect seed n list =
    let 
        (l, r, s) = randSelect n ([], list, seed)
    in
        l
    
    
randSelect : Int -> (List a, List a, Random.Seed) -> (List a, List a, Random.Seed)
randSelect n (l, r, seed) =
    if n > 0 then
        let 
            (rand, seed') = Random.generate (Random.int 1 (List.length r)) seed
            e = elementAt rand r
            r' = dropAt rand r
        in
            case e of 
                Nothing ->
                    (l, r, seed)
                    
                Just x ->
                    randSelect (n-1) (x::l, r', seed')
    else
        (l, r, seed)
        
        
elementAt : List a -> Int -> Maybe a 
elementAt list n = 
    case List.drop (n - 1) list of 
        [] -> 
            Nothing 

        y :: ys -> 
            Just y
            
dropAt : List a -> Int -> List a
dropAt list n =
 case list of
 [] -> []
 x :: xs ->
 (List.take (n - 1) list) ++ (List.drop n list)

main =
  App.program
    { init = init
    , view = view
    , update = update
    , subscriptions = subscriptions
    }



-- MODEL


type alias Model =
  { dieFace : Int
  }


init : (Model, Cmd Msg)
init =
  (Model 1, Cmd.none)



-- UPDATE


type Msg
  = Roll
  | NewFace Int


update : Msg -> Model -> (Model, Cmd Msg)
update msg model =
  case msg of
    Roll ->
      (model, Random.generate NewFace (Random.int Random.minInt Random.maxInt))

    NewFace newFace ->
      (Model newFace, Cmd.none)



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions model =
  Sub.none



-- VIEW


view : Model -> Html Msg
view model =
  div []
    [ h1 [] [ text (toString model.dieFace) ]
    , button [ onClick Roll ] [ text "Roll" ]
    ]

```

## Hints

##Solutions 
[Solutions](../s/s23.md)