# Problem 80

##Graphs

A graph is defined as a set of nodes and a set of edges, where each edge is a pair of nodes. Throughout these problems we will represent nodes with single characters.

![](../i/graph1.gif)

There are several ways to represent graphs. One method is to represent each edge separately.

---

## Edge-clause form
```elm
type Edges a = List((a,a))
edges80 = [ ('b','c'), ('b','f'), ('c','f'), ('f','k'), ('g','h')]
```

We call this edge-clause form. The edge-clause cannot represent isolated nodes. 

---

##Graph-term form

To represent the whole graph we can use as a pair of sets (nodes and edges).


```elm
type Graph a = (List(a), Edges a)
graph80 = ( [ 'b', 'c', 'd', 'f', 'g', 'h', 'k' ],
  [ ('b','c'), ('b','f'), ('c','f'), ('f','k'), ('g','h') ] )
```
We call this the graph-term form. It will be our default representation in these problems. Note that the lists should be kept sorted and should not include duplicated elements. Each edge appears only once in the edge list; i.e. an edge ```('x','y')``` represents one edge between x and y. The term ```('y','x')``` is not shown. 

---

##Adjancency list form
A third representation method is to associate with each node the set of nodes that are adjacent to that node. We call this the adjacency-list form. In our example:

```elm
type AdjList a = List((a, List a))
adjList80 = 
[ ('b',['c','f']), 
  ('c',['b','f']), 
  ('d',[]), 
  ('f',['b','c','k']), 
  ('k',['f']), 
  ('h',['g'])
]
```
---

##Human-readable form

Typing the terms by hand is cumbersome and error-prone. We can define a more compact and "human-readable" notation as follows:

```
hm80 = "[b-c, f-c, g-h, d, f-b, k-f, h-g]"
```
We call this the human-friendly form. The list does not have to be sorted and may even contain the same edge multiple times. Notice the isolated node d. Unlike the Graph and AdjList type, this is textual representation, not a type. 

---
##Arc-clause form

When the edges are directed we call them arcs. These are represented by ordered pairs. Such a graph is called directed graph. To represent a directed graph, the forms discussed above are slightly modified. 

![](../i/graph2.gif)

```elm
type Arcs a = List((a,a))
arcs80 =  [ ('s','r')
          , ('s','u')
          , ('u','r')
          , ('u','s')
          , ('v','u')]
```

---

##Digraph-term form
A directed graph, or digraph, uses arcs instead of edges. 

digraph([r,s,t,u,v],[a(s,r),a(s,u),a(u,r),a(u,s),a(v,u)])
Adjacency-list form

[n(r,[]),n(s,[r,u]),n(t,[]),n(u,[r]),n(v,[u])]
Note that the adjacency-list does not have the information on whether it is a graph or a digraph.

Human-friendly form

[s > r, t, u > r, s > u, u > s, v > u] 
Finally, graphs and digraphs may have additional information attached to nodes and edges (arcs). For the nodes, this is no problem, as we can easily replace the single character identifiers with arbitrary compound terms, such as city('London',4711). On the other hand, for edges we have to extend our notation. Graphs with additional information attached to edges are called labelled graphs.

graph3.gif

Arc-clause form

arc(m,q,7).
arc(p,q,9).
arc(p,m,5).
Graph-term form

digraph([k,m,p,q],[a(m,p,7),a(p,m,5),a(p,q,9)])
Adjacency-list form

[n(k,[]),n(m,[q/7]),n(p,[m/5,q/9]),n(q,[])]
Notice how the edge information has been packed into a term with functor '/' and arity 2, together with the corresponding node.

Human-friendly form

[p>q/9, m>q/7, k, p>m/5]
The notation for labelled graphs can also be used for so-called multi-graphs, where more than one edge (or arc) are allowed between two given nodes.

```elm
graphToAdjList g : Graph -> AdjacencyList

adjListToGraph al : AdjancencyList -> Graph

```

```
import Html exposing (text)


al = [('b',['c','f']), ('c',['b','f']), ('d',[]), ('f',['b','c','k']), ('g',['h'])]


g = ['b','c','d','f','g','h','k'],[('b','c'),('b','f'),('c','f'),('f','k'),('g','h')]


main =
    text toString (== (graphToAdjList g) (adjListToGraph al) )         
```

Result
```
True
```
