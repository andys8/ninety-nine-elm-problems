# Problem 80

##Graphs

A graph is defined as a set of nodes and a set of edges, where each edge is a pair of nodes. Throughout these problems we will represent nodes with single characters.

![](../i/graph1.gif)

There are several ways to represent graphs. One method is to represent each edge separately.

---

## Edge-clause form
```elm
type Edge a = (a, a)

edges80 = [ ('b','c'), ('b','f'), ('c','f'), ('f','k'), ('g','h')]
```

We call this edge-clause form. The edge-clause cannot represent isolated nodes. 

---

##Graph-term form

To represent the whole graph we can use as a pair of sets (nodes and edges).


```elm
type Graph a = (List a, List (Edge a))
graph80 = ( [ 'b', 'c', 'd', 'f', 'g', 'h', 'k' ],
  [ ('b','c'), ('b','f'), ('c','f'), ('f','k'), ('g','h') ] )
```
We call this the graph-term form. It will be our default representation in these problems. Note that the lists should be kept sorted and should not include duplicated elements. Each edge appears only once in the edge list; i.e. an edge ```('x','y')``` represents one edge between x and y. The term ```('y','x')``` is not shown. 

---

##Adjancency list form
A third representation method is to associate with each node the set of nodes that are adjacent to that node. We call this the adjacency-list form. In our example:

```elm
type AdjList a = List((a, List a))
adjList80 = 
[ ('b',['c','f']), 
  ('c',['b','f']), 
  ('d',[]), 
  ('f',['b','c','k']), 
  ('k',['f']), 
  ('h',['g'])
]
```
---

##Human-readable form

Typing the terms by hand is cumbersome and error-prone. We can define a more compact and "human-readable" notation as follows:

```
hm80 = "[b-c, f-c, g-h, d, f-b, k-f, h-g]"
```
We call this the human-friendly form. The list does not have to be sorted and may even contain the same edge multiple times. Notice the isolated node d. Unlike the Graph and AdjList type, this is textual representation, not a type. 

---
##Directed Graphs

When the edges are directed we call them arcs. These are represented by ordered pairs. Such a graph is called directed graph. We can reuse the graph notation with little or no change, to represent digraphs. 

![Digraph80](../i/graph2.gif)


```elm
type Arc a = (a,a)

arcs80 =  [ ('s','r')
          , ('s','u')
          , ('u','r')
          , ('u','s')
          , ('v','u')]

type Digraph a = (List a, List (Arc a))

digraph80 = ( [ 'r', 's', 't', 'u', 'v'], arcs80 )

type DirAdjList a = List((a, List a))
dirAdjList80 =  [ (r,[])
                , (s,[r,u])
                , (t,[])
                , (u,[r])
                , (v,[u])
                ]
                
-- human-readable digraph
hrDigraph80 = "[s > r, t, u > r, s > u, u > s, v > u]" 
```

---
##Labeled graphs
Finally, graphs and digraphs may have additional information attached to nodes and edges (arcs). For edges and arc we have to extend our notation. Graphs with additional information attached to edges are called labeled graphs.

![](../i/graph3.gif)

```elm
type Arc a = (a, a, Int)
labeledArcs80 = 
    [ (m,q,7)
    , (p,q,9)
    , (p,m,5)
    ]
```
Graph-term form

digraph([k,m,p,q],[a(m,p,7),a(p,m,5),a(p,q,9)])
Adjacency-list form

[n(k,[]),n(m,[q/7]),n(p,[m/5,q/9]),n(q,[])]
Notice how the edge information has been packed into a term with functor '/' and arity 2, together with the corresponding node.

Human-friendly form

[p>q/9, m>q/7, k, p>m/5]
The notation for labelled graphs can also be used for so-called multi-graphs, where more than one edge (or arc) are allowed between two given nodes.

```elm
graphToAdjList g : Graph -> AdjacencyList

adjListToGraph al : AdjancencyList -> Graph

```

```
import Html exposing (text)


al = [('b',['c','f']), ('c',['b','f']), ('d',[]), ('f',['b','c','k']), ('g',['h'])]


g = ['b','c','d','f','g','h','k'],[('b','c'),('b','f'),('c','f'),('f','k'),('g','h')]


main =
    text toString (== (graphToAdjList g) (adjListToGraph al) )         
```

Result
```
True
```
