#Problem 50 - Huffman Encoding 
Huffman coding uses variable bit length codes to efficiently encode data. By giving the frequently found values short codes and rarely used values longer codes, it's possible to compress data. The first step in Huffman encoding is to determine the frequency of every value in the input data. 

##Example
```elm 
freqs [1, 20, 20, 3, 3, 3, 3] == [(1, 1), (2, 20), (4, 3)]
```

##Unit Test
```elm
import Html
import List

freqs : List a -> List (Int, a)
freqs list = 
    -- your implementation goes here
    []

main =
    Html.text
        (if (test) then
            "Your implementation passed all tests."
         else
            "Your implementation failed at least one test."
        )


test : Bool
test =
    List.all ((==) True)
        [ freqs [] == []
        , sortFreqs ( freqs [20, 3, 20, 3, 1, 3, 3] ) == [(1, 1), (2, 20), (4, 3)]
        , sortFreqs ( freqs [3, 3, -20, 1, 3, 3, -20] ) == [(1, 1), (2, -20), (4, 3)]
        ]


sortFreqs : List (Int, a) -> List (Int, a)
sortFreqs list = 
    List.sortBy (\(l, v) -> l) list
```

#Hints
1. Look at [Problem 11](p/p11.md). How can you make run lengths be the frequency? 

## Solutions
[Solutions](../s/s49.md) 