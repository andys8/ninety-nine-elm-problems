# Problem 88

Split a graph into its connected components.

##Example
```
connected ([1,2,3,4,5,6,7], [(1,2),(2,3),(1,4),(3,4),(5,2),(5,4),(6,7)])
  == [[1,2,3,4,5][6,7]]
```

## Unit Test
```elm
import Html
import List
import Set
import String


type alias Edge comparable =
    ( comparable, comparable )


type alias Graph comparable =
    ( List comparable, List (Edge comparable) )


{-| Given a graph, return connected subsets of nodes.
-}
connected : Graph comparable -> List (List comparable)
connected (nodes, edges) =
    case nodes of
        [] ->
            []
          
        n::ns ->
            let 
                subNodes = depthFirst n (nodes, edges)
            in
                subNodes :: connected ((diff nodes subNodes), edges)   
                   
                   
{-| return the set of elements of a list not found in another list 
-}
diff : List comparable -> List comparable -> List comparable
diff minuend subtraend =
    Set.toList <| Set.diff (Set.fromList minuend) (Set.fromList subtraend)
        

{-| Given a graph and a starting node, return all nodes in depth-first order.
-}
depthFirst : comparable -> Graph comparable -> List comparable
depthFirst start (nodes, edges) =
    List.reverse (depthFirst' [start] [] (nodes, edges))


{-| Helper function for depthFirst that recordes visited nodes to avoid
    cyclic paths.
-}
depthFirst' : List comparable -> List comparable -> Graph comparable -> List comparable
depthFirst' unvisited visited ( nodes, edges ) =
    case unvisited of
        [] ->
            visited
           
        u::us ->
            let
                nextNodes = unique
                    <| List.map (snd)
                    <| (++) (List.filter (\( a, b ) -> a == u) edges)
                    <| List.map (\x -> ( snd x, fst x ))
                    <| List.filter (\( a, b ) -> b == u) edges

                newNodes = List.sort
                    <| List.filter (\x -> not (List.member x (u::visited))) nextNodes
            in
                depthFirst' (remove u (newNodes ++ unvisited)) (u::visited) (nodes, edges)


remove : a -> List a -> List a
remove x =
  List.filter ((/=) x)
  

{-| Given a list, return all unique values in the list.
-}
unique : List comparable -> List comparable
unique list =
    Set.toList <| Set.fromList list


main' = Html.text <| toString <| connected graph80
main : Html.Html a
main =
    Html.text
        <| case test of
            0 ->
                "Your implementation passed all tests."

            1 ->
                "Your implementation failed one test."

            x ->
                "Your implementation failed " ++ (toString x) ++ " tests."


test : Int
test =
    List.length
        <| List.filter ((==) False)
            [ (List.sort (connected graph80)) 
                ==  [ ['b', 'c', 'f', 'k']
                    , ['d']
                    , ['g', 'h']
                    ]
            , (connected ([], [])) == []
            , (connected ([1, 2, 3], [])) == [[1], [2], [3]]
            , (connected ([1, 2, 3], [(1,2), (2,3)])) == [[1,2,3]]
            ]


graph80 =
    ( [ 'b', 'c', 'd', 'f', 'g', 'h', 'k' ]
    , [ ( 'b', 'c' )
      , ( 'b', 'f' )
      , ( 'c', 'f' )
      , ( 'f', 'k' )
      , ( 'g', 'h' )
      ]
    )

```

## Hint
1. Which previous graph problem will extract one connected component?

## Solution
[Solution](../s/88.md)