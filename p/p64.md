# Problem 64

To draw a tree a layout algorithm determines the position of each node in a rectangular grid. Several layout methods are conceivable, one of them is illustrated below:

![](../i/p64.gif)

In this layout strategy, the following two rules determine the position:
* ```x(v)``` is equal to the position of the node ```v``` in the inorder sequence
* ```y(v)``` is equal to the depth of the node ```v``` in the tree. 

Write a function to annotate each node of the tree with its position. 

##Example
```elm 
tree64 = 
  Node 'n'
    (Node 'k'
      (Node 'c'
        (Node 'a' Empty Empty)
        (Node 'h'
          (Node 'g'
            (Node 'e' Empty Empty)
            Empty)
          Empty))
      (Node 'm' Empty Empty))
    (Node 'u'
      (Node 'p'
        Empty
          (Node 's'
            (Node 'q' Empty Empty)
            Empty))
      Empty)
                
layout tree64 ==  
  Node ('n',(8,1)) (Node ('k',(6,2)) (Node ('c',(2,3)) ...

```

##Unit Test
```elm

import Html
import List


type Tree a
    = Empty
    | Node a (Tree a) (Tree a)


tree64 = 
  Node 'n'
    (Node 'k'
      (Node 'c'
        (Node 'a' Empty Empty)
        (Node 'h'
          (Node 'g'
            (Node 'e' Empty Empty)
            Empty)
          Empty))
      (Node 'm' Empty Empty))
    (Node 'u'
      (Node 'p'
        Empty
          (Node 's'
            (Node 'q' Empty Empty)
            Empty))
      Empty)


layout : Tree a -> Tree (a, (Int, Int))
layout tree =
    treeMap addXY tree
      |> treeMapDepth setY 1
      |> treeMapInOrder setX 1

addXY : a -> (a, (Int, Int))
addXY v =
    (v, (0, 0))


setY : Int -> (a, (Int, Int)) -> (a, (Int, Int))
setY n (v, (x, y)) =
    (v, (x, n))


setX : Int -> (a, (Int, Int)) -> (a, (Int, Int))
setX n (v, (x, y)) =
    (v, (n, y))

    
treeMap : (a -> b) -> Tree a -> Tree b
treeMap f tree =   
    case tree of 
        Empty -> 
            Empty

        Node v left right ->
            Node (f v) (treeMap f left) (treeMap f right)


-- apply a function to each node, passing the depth as a parameter
treeMapDepth : (Int -> a -> b) -> Int -> Tree a -> Tree b
treeMapDepth f d tree =   
    case tree of 
        Empty -> 
            Empty

        Node v left right ->
            Node (f d v) 
                (treeMapDepth f (d + 1) left) 
                (treeMapDepth f (d + 1) right)


-- apply a function to each node, passing the in-order index as a parameter
treeMapInOrder : (Int -> a -> b) -> Int -> Tree a -> Tree b
treeMapInOrder f n tree =   
    case tree of 
        Empty -> 
            Empty

        Node v left right ->
            let 
                n' = (n + (treeCount left))
            in 
                Node  (f n' v) 
                    (treeMapInOrder f n left)
                    (treeMapInOrder f (n' + 1) right)


-- count number of Nodes in a Tree    
treeCount : Tree a -> Int
treeCount tree = 
    case tree of 
        Empty -> 0

        Node n left right ->
            1 + (treeCount left) + (treeCount right)
            
            
main =
    Html.text
        (if (test) then
            "Your implementation passed all tests."
         else
            "Your implementation failed at least one test."
        )


test : Bool
test =
    let 
        t = layout tree64 
    in 
        List.all ((==) True)
          [ t == layout64
          ]

layout64 = 
  Node ('n', (8, 1))
    (Node ('k', (6, 2))
      (Node ('c', (2, 3))
        (Node ('a', (1, 4)) Empty Empty)
        (Node ('h', (5, 4))
          (Node ('g', (4, 5))
            (Node ('e', (3, 6)) Empty Empty)
            Empty)
          Empty))
      (Node ('m', (7, 3)) Empty Empty))
    (Node ('u', (12, 2))
      (Node ('p', (9, 3))
        Empty
        (Node ('s', (11, 4))
          (Node ('q', (10, 5)) Empty Empty)
          Empty))
      Empty)
      
        
```

##Solutions
[Solutions](../s/64.md)


