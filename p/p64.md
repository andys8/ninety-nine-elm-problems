# Problem 64

To draw a tree a layout algorithm determines the position of each node in a rectangular grid. Several layout methods are conceivable, one of them is illustrated below:

![](../i/p64.gif)

In this layout strategy, the following two rules determine the position:
* ```x(v)``` is equal to the position of the node ```v``` in the inorder sequence
* ```y(v)``` is equal to the depth of the node ```v``` in the tree. 

Write a function to annotate each node of the tree with its position. 

##Example
```elm 
tree64 = 
  Node 'n'
    (Node 'k'
      (Node 'c'
        (Node 'a' Empty Empty)
        (Node 'h'
          (Node 'g'
            (Node 'e' Empty Empty)
            Empty)
          Empty))
      (Node 'm' Empty Empty))
    (Node 'u'
      (Node 'p'
        Empty
          (Node 's'
            (Node 'q' Empty Empty)
            Empty))
      Empty)
                
layout tree64 ==  
  Node ('n',(8,1)) (Node ('k',(6,2)) (Node ('c',(2,3)) ...

```

##Unit Test
```elm

import Html
import List


type Tree a
    = Empty
    | Node a (Tree a) (Tree a)


tree64 = 
  Node 'n'
    (Node 'k'
      (Node 'c'
        (Node 'a' Empty Empty)
        (Node 'h'
          (Node 'g'
            (Node 'e' Empty Empty)
            Empty)
          Empty))
      (Node 'm' Empty Empty))
    (Node 'u'
      (Node 'p'
        Empty
          (Node 's'
            (Node 'q' Empty Empty)
            Empty))
      Empty)
      

layout : Tree a -> Tree (a, (Int, Int))
layout tree =
    layoutOrder 1 <| layoutDepth tree 0 1
    
    
layoutDepth : Tree a -> Int -> Int -> Tree (a, (Int, Int))
layoutDepth tree order depth =
    case tree of 
        Empty -> 
            Empty
        
        Node v left right ->
            Node (v, (order, depth)) 
                  (layoutDepth left order (depth + 1)) 
                  (layoutDepth right order (depth + 1))


layoutOrder : Int -> Tree (a, (Int, Int)) -> Tree (a, (Int, Int))
layoutOrder order tree =
    case tree of 
        Empty -> 
            Empty
        
        Node (v, (x, y)) left right ->
            Node (v, (order, y)) 
                  (layoutOrder order left) 
                  (layoutOrder order right)


main' = Html.text <| toString <| layout tree64
main =
    Html.text
        (if (test) then
            "Your implementation passed all tests."
         else
            "Your implementation failed at least one test."
        )


layout64 = 
  Node ('n', (1, 1))
    (Node ('k', (1, 2))
      (Node ('c', (1, 3))
        (Node ('a', (1, 4)) Empty Empty)
        (Node ('h', (1, 4))
          (Node ('g', (1, 5))
            (Node ('e', (1, 6)) Empty Empty)
            Empty)
          Empty))
      (Node ('m', (1, 3)) Empty Empty))
    (Node ('u', (1, 2))
      (Node ('p', (1, 3))
        Empty
        (Node ('s', (1, 4))
          (Node ('q', (1, 5)) Empty Empty)
          Empty))
      Empty)
      
test : Bool
test =
    let 
        t = layout tree64 
    in 
        List.all ((==) True)
          [ t == layout64
          ]
        
```

##Solutions
[Solutions](../s/64.md)


